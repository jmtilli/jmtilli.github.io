<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 5. How Stirmake executes its commands</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Scalable true implementation of recursive make (stirmake), user's guide" /><link rel="up" href="pt02.html" title="Part II. Stirmake, a modern tool" /><link rel="prev" href="ch04.html" title="Chapter 4. Variables, data types and functions" /><link rel="next" href="ch06.html" title="Chapter 6. Automated cleaning with stirmake" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 5. How Stirmake executes its commands</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04.html">Prev</a> </td><th width="60%" align="center">Part II. Stirmake, a modern tool</th><td width="20%" align="right"> <a accesskey="n" href="ch06.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="commands"></a>Chapter 5. How Stirmake executes its commands</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="ch05.html#idp3">Different ways of executing commands</a></span></dt><dt><span class="sect1"><a href="ch05.html#idp4">The dangers of shell expansion</a></span></dt><dt><span class="sect1"><a href="ch05.html#idp5">Invoking shell manually</a></span></dt><dt><span class="sect1"><a href="ch05.html#idp6">Build command, timestamp and file size database</a></span></dt><dt><span class="sect1"><a href="ch05.html#idp7">Move madness</a></span></dt><dt><span class="sect1"><a href="ch05.html#idp8">Command options: ignore, noecho, ismake, automatic make detection</a></span></dt><dt><span class="sect1"><a href="ch05.html#idp9">@glob and the dangers of @glob in middle of many commands</a></span></dt></dl></div>
    
    <div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3"></a>Different ways of executing commands</h2></div></div></div>
      
<p>

Make executes its commands always via the Bourne shell /bin/sh. Stirmake can
either use the shell or omit its use, at the Stirfile author's preference.

</p><p>

The same syntax that is used in make too executes the command after tabulator
via shell:

</p><pre class="programlisting">
@toplevel
@strict
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
	cc -o $@ $&lt;
</pre><p>

</p><p>

In this case, the command is sh -c "cc -o $@ $&lt;". To omit shell and invoke
the compiler directly, you can use the @-tab syntax, which takes a list of
command-line arguments:

</p><pre class="programlisting">
@toplevel
@strict
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
@	["cc", "-o", $@, $&lt;]
</pre><p>

</p><p>

Also sometimes you may want to include more than one command in a single
line. It is possible with the @@-tab syntax:

</p><pre class="programlisting">
@toplevel
@strict
@phonyrule: 'all': 'hello'
'libhello.a': 'hello.o'
@@	[["rm", "-f", $@], ["ar", "rvs", $@, @@suffilter($^, ".o")]]
</pre><p>

In this case, after the tabulator you have an array of arrays of strings, not a
simple array of strings.

</p>
    </div>
    <div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4"></a>The dangers of shell expansion</h2></div></div></div>
      
<p>

Shell expansion may not always do what you want. Firstly, spaces in file names
cause the file name to be split to multiple command-line arguments. The shell
also assigns special meanings to many characters like `, \ and $. Stirmake does
not have any attempt at shell escaping to support for example dollar signs
in file names. Stirmake's way to allow dollar signs in file names is to not use
shell, but instead invoke the compiler directly with no shell inbetween.

</p>
    </div>
    <div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5"></a>Invoking shell manually</h2></div></div></div>
      
<p>

Of course, with the @-tab syntax it's possible to specify the shell manually:

</p><pre class="programlisting">
@toplevel
@strict
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
@	["sh", "-c", "cc -o " . $@ . " " . $&lt;]
</pre><p>

</p><p>

Note that the -c option takes only one argument, so everything has to be
concatenated to a string with space as argument delimiter.

</p>
    </div>
    <div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6"></a>Build command, timestamp and file size database</h2></div></div></div>
      
<p>

Stirmake has database which tells what commands have been executed to create
the targets, and full timestamp and file size information for the targets. This
default mode is used whenever -e is not specified as the command line argument.
The uppercase -E on the other hand explicitly turns on this default mode. If
-e is used, the database contains only build commands but not file timestamps
and file sizes. The version of database is in this case @v1@.

</p><p>

An example of the database when -E is used:
</p><pre class="programlisting">
@v2@

"." "prog":
	"NI" "E" "NM" "cc" "-Wall" "-O3" "-o" "prog" "hello.o"

"." "hello.o":
	"NI" "E" "NM" "cc" "-Wall" "-O3" "-c" "-o" "hello.o" "hello.c"

"." "hello.d":
	"NI" "E" "NM" "cc" "-Wall" "-O3" "-MM" "-o" "hello.d" "hello.c"

"hello.d" = 17 1759334220 851355669

"hello.c" = 27 1759334155 483267579

"hello.o" = 1456 1759334220 879355707

"prog" = 16464 1759334220 895355729
</pre><p>

</p><p>

The @v2@ specifier at beginning tells the version (v1: just commands, v2: also
file sizes and timestamps). The first three files are mentioned along with the
commands that were used to build the files. The first "NI", "E", "NM" are
command settings (no-ignore / ignore, echo / no-echo, no-make / is-make) and
the rest is the command that was used.

</p><p>

The last four files are mentioned along with their sizes in bytes and the
modification timestamp of the files. If the file size or timestamp differs,
it can be concluded that rebuild is necessary.

</p>
    </div>
    <div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7"></a>Move madness</h2></div></div></div>
      
<p>

Let us assume that you have the following Makefile:

</p><pre class="programlisting">
hello: hello.c
	cc -o hello hello.c
</pre><p>

</p><p>

You want to take a backup of hello.c before you start modifying it. Then you
modify it and run "make". Then for some reason you want to restore the old
unmodified version. Then you run "make", and find that "make" won't build
anything:
</p><pre class="programlisting">
cp hello.c hello.c.bak
$EDITOR hello.c
make
mv hello.c.bak hello.c
make
</pre><p>

</p><p>

In this case, the cp command creates a new timestamp for the copy, but it's
before the timestamp of edited hello.c and before the timestamp of the binary
hello which make created. However, mv is different from cp. Whereas cp creates
a new timestamp, mv does a rename and doesn't touch the timestamp. Therefore,
after the mv command, hello.c timestamp and possibly file size did change, but
it didn't become newer than the timestamp of the hello binary. Therefore, with
standard make, hello won't be rebuilt. This anomaly can be called
<span class="emphasis"><em>move madness</em></span>.

</p><p>

Stirmake is immune to move madness, since stirmake has a file size, command
and timestamp database. In this example of move madness, at least the timestamp
of hello.c did change although it didn't become newer than the timestamp of
hello binary. Also it's possible the file size changed. In this case, stirmake
has enough information to conclude that the file has in fact changed, and
does a rebuild.

</p>
    </div>
    <div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8"></a>Command options: ignore, noecho, ismake, automatic make detection</h2></div></div></div>
      
<p>

Stirmake supports three command options: @ignore, @noecho and @ismake.

</p><p>

Normally, all commands that stirmake executes are echoed to standard output,
unless the -s (silent) option is given as argument. However, individual command
echoing can be disabled with @noecho. This is useful if the list of commands
has an "echo" command, which would then be echoed twice: first the full command
name, then the argument to "echo". How to do this:

</p><pre class="programlisting">
@toplevel
@strict
@phonyrule: 'all':
@	@noecho ["echo", "foo"]
</pre><p>

</p><p>

Also, normally, a command that fails stops the build process. All commands must
return "true" exit status, 0, not "false" (which would be nonzero). To allow
command returning false to not stop the build, use @ignore:

</p><pre class="programlisting">
@toplevel
@strict
@phonyrule: 'all':
@	@ignore ["false"]
@	@noecho ["echo", "false was ignored"]
</pre><p>

</p><p>

Stirmake needs to know if the sub-process it executes is GNU make. The reason
being that GNU make requires a jobserver, which stirmake has to offer via
environment variables. Normally, stirmake compares the program name with a
built-in list of known GNU make names:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">make</li><li class="listitem">gmake</li><li class="listitem">/usr/bin/make</li><li class="listitem">/usr/bin/gmake</li><li class="listitem">/usr/local/bin/make</li><li class="listitem">/usr/local/bin/gmake</li><li class="listitem">/usr/pkg/bin/make</li><li class="listitem">/usr/pkg/bin/gmake</li><li class="listitem">/opt/bin/make</li><li class="listitem">/opt/bin/gmake</li><li class="listitem">/opt/gnu/bin/make</li><li class="listitem">/opt/gnu/bin/gmake</li><li class="listitem">/bin/make</li><li class="listitem">/bin/gmake</li></ul></div><p>

However, if GNU make is invoked with a command that is not present in this
list, it is possible to mark the command as GNU make with @ismake:
</p><pre class="programlisting">
@toplevel
@strict
@phonyrule: 'all':
@	@ismake ["/opt/bin/gnumake", "-C", "subdir"]
</pre><p>

</p>
    </div>
    <div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp9"></a>@glob and the dangers of @glob in middle of many commands</h2></div></div></div>
      
<p>

Stirmake has a feature @glob to evaluate shell glob patterns, using the glob()
interface without actually invoking the shell. However, its usage is somewhat
limited as a list of commands has to have all commands evaluated before the
commands can be executed, because stirmake has command database and needs to
compare the current list of commands against the list as of previous
invocation.

</p><p>

Consider for example that you have a zip file and you want to unzip it but
remove all text files:

</p><pre class="programlisting">
@toplevel
@strict
@phonyrule: 'unzip': 'zip.zip'
@	["unzip", "zip.zip"]
@	["rm", @@glob("*.txt")]
</pre><p>

Now the question is, how does this work? Does it execute @glob before or after
unzip? The unfortunate news is that stirmake has to have full knowledge of the
build commands before they can be executed, because if the list is equal to
the previous list of commands and if none of the files have been changed, it
is pointless to invoke the commands. So, the @glob has to be executed before
unzip is called. Therefore, the list of text files does not have any text files
that were created by unzipping the archive.

</p><p>

This problem can be avoided by using the shell:

</p><pre class="programlisting">
@toplevel
@strict
@phonyrule: 'unzip': 'zip.zip'
@	["unzip", "zip.zip"]
@	["sh", "-c", "rm *.txt"]
</pre><p>

Now since the glob evaluation result isn't part of the command, this works fine
since stirmake doesn't have to evaluate *.txt but rather the shell evaluates
it. What *.txt evaluates to, isn't part of the build command database.

</p><p>

Where glob is useful is for example automatic creation of rules from .c to .d
and .o:
</p><pre class="programlisting">
@toplevel
@strict
$CC="cc"
$CFLAGS=["-Wall", "-O3"]
$SRC=@glob("*.c")
$DEP=@sufsuball($SRC, ".c", ".d")
$OBJ=@sufsuball($SRC, ".c", ".o")
'prog': $(OBJ)
@	[$CC, @$CFLAGS, "-o", $@, @@suffilter($^, ".o")]
@patrule: $(OBJ): '%.o': '%.c' '%.d'
@	[$CC, @$CFLAGS, "-c", "-o", $@, $&lt;]
@patrule: $(DEP): '%.d': '%.c'
@	[$CC, @$CFLAGS, "-MM", "-o", $@, $&lt;]
@cdepincludes @autophony @autotarget @ignore $DEP
</pre><p>

In this example, the Stirfile does not need to be modified whenever a new
.c file is created to the directory. It is up to the reader to decide whether
this feature in Stirfile is good, or whether Stirfile should have an explicit
list of what to compile.

</p>
    </div>
  </div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="pt02.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch06.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 4. Variables, data types and functions </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 6. Automated cleaning with stirmake</td></tr></table></div></body></html>