<!DOCTYPE html>

<html><head><title>jmtilli.github.io</title></head><body>

<h1>Juha-Matti Tilli's Github portfolio (https://jmtilli.github.io/)</h1>

<p>This is my Github portfolio in a format where repositories are not just
listed like on the <a href="https://github.com/jmtilli">Github profile page</a>
but also described in more detail. My Github profile page has also several
minor repositories that are too unimportant to be listed here, and forks of
software written by others that I do not want to falsely list here as my
own.</p>

<img src="picture2.jpg" alt="Photo of Juha-Matti Tilli" width="288" height="288" />

<h2>stirmake user's guide</h2>

<p><a href="https://github.com/jmtilli/stirmakeguide">stirmakeguide in Github</a>, <a href="https://jmtilli.github.io/stirmakeguide/">rendered version of user's guide</a></p>

<p>Stirmake is scalable true implementation of recursive make. It is intended
for easily creating whole-project build systems consisting of numerous modules.
Numerous deficiencies in standard make have been solved while staying true to
the idea of traditional make. For understanding why stirmake is necessary, read
<a href="http://aegis.sourceforge.net/auug97.pdf">"Recursive Make Considered
Harmful"</a> and try to follow its instructions. Here is the user's guide of stirmake which is the most comprehensive document about it.</p>

<h2>CamFTPD</h2>

<p><a href="https://github.com/jmtilli/camftpd">CamFTPD in Github</a></p>

<p>CamFTPD is an FTP server intended for surveillance cameras. The only
operation it supports is putting new files, it doesn't support getting files,
deleting files, listing files, etc. The put operation refuses to overwrite
existing files. So the surveillance camera can only append new data, never
access or destroy old data. The reasoning why CamFTPD should be used is that
FTP sends cleartext passwords over the wire, and there is no widely supported
replacement standard for FTP although SFTP/SCP could be used if surveillance
cameras only supported it. So, if the attacker can physically access the
network connection of a surveillance camera, the only harm the attacker can do
is inserting false evidence. However, prior to the timestamps of the false
evidence, the attacker's true face has already been caught while tampering with
the network connection.</p>

<h2>RLCTrans</h2>

<p><a href="https://github.com/jmtilli/rlctrans">RLCTrans in Github</a></p>

<p>RLCTrans is a transient simulator program for R-L-C circuits with switches,
diodes, transformers and voltage sources. The analysis is linear nodal analysis
with automatic reanalyses if diode current direction changes. Two models for a
transformer are provided: a single transformer may be handled by binary search
which slows down the simulation markedly, but a linear matrix model allows
multiple transformers and fast simulation. The software is especially intended
for designing control algorithms for switched mode power supplies, sine wave
inverters and active power factor correction circuits and analyzing what kind
of core is needed for the inductors to avoid saturation. For analyzing energy
efficiency of SMPS, the software is utterly inadequate. The software does not
aim to compete with Spice: it only simulates the high-power path of MOSFET and
BJT switches and does not analyze the gate/base control of the switches at all.
However, most likely in many cases the software runs way faster than Spice
does, and it is easy to integrate it with C code which you would use as the
programming language of choice for developing software running on the control
microcontrollers anyway.</p>

<h2>nodexmlfrag</h2>

<p><a href="https://github.com/jmtilli/nodexmlfrag">nodexmlfrag in
Github</a>, <a href="https://www.npmjs.com/package/nodexmlfrag">nodexmlfrag in NPM</a></p>

<p>Typically, XML is either parsed by a tree-based parser or by an event-based
parser. Event-based parsers are fast and have a low memory footprint, but a
drawback is that it is cumbersome to write the required event handlers.
Tree-based parsers make the code easier to write, to understand and to maintain
but have a large memory footprint as a drawback. Often, XML is used for huge
files such as database dumps that necessitate event-based parsing, or so it
would appear at a glance, because a tree-based parser cannot hold the whole
parse tree in memory at the same time. NodeXMLFrag allows XML to be parsed by
event-based approach from the top, but allowing switching to a tree-based
approach for small structures. So for example a database dump containing
billion objects can be parsed in an event-based manner but each object can be
parsed into a tree.</p>

<h2>pyxmlfrag</h2>

<p><a href="https://github.com/jmtilli/pyxmlfrag">pyxmlfrag in
Github</a>, <a href="https://pypi.org/project/pyxmlfrag/">pyxmlfrag in PyPI</a></p>

<p>Typically, XML is either parsed by a tree-based parser or by an event-based
parser. Event-based parsers are fast and have a low memory footprint, but a
drawback is that it is cumbersome to write the required event handlers.
Tree-based parsers make the code easier to write, to understand and to maintain
but have a large memory footprint as a drawback. Often, XML is used for huge
files such as database dumps that necessitate event-based parsing, or so it
would appear at a glance, because a tree-based parser cannot hold the whole
parse tree in memory at the same time. PyXMLFrag allows XML to be parsed by
event-based approach from the top, but allowing switching to a tree-based
approach for small structures. So for example a database dump containing
billion objects can be parsed in an event-based manner but each object can be
parsed into a tree.</p>

<h2>MPloop</h2>

<p><a href="https://github.com/jmtilli/mploop">MPloop in Github</a></p>

<p>MPloop is a set of scripts for playing music in the background. The idea is
that the "loop" part, which is a script that reads the queue and plays songs in
that order, is started in a screen or tmux session. The "loop" uses MPlayer or
a custom included music player as the tool for playing music.</p>

<p>All of the songs are played from queue in the order they are in the
queue.</p>

<p>The user interface is simply a set of scripts managing the queue from a Unix
shell, and a set of scripts controlling the player.</p>

<h2>Pretty floating point to ASCII (prettyftoa)</h2>

<p><a href="https://github.com/jmtilli/prettyftoa">prettyftoa in Github</a></p>

<p>Sometimes there is a need to convert a floating point number to a string
representation that converts back to the same number. The usual approach is a
format specifier with enough precision such as "%.17g". However, there are
several problems with this approach such as the fact that the floating point
number 2.0 converts to the string "2" that incorrectly implies it is an
integer. Also the floating point number 0.2 converts to "0.20000000000000001"
instead of "0.2". The pretty ftoa library attempts to find the shortest
"pretty" representation for a floating point number that still converts back to
the same number and that clearly demonstrates the number is a floating point
number and not an integer.</p>

<h2>Streaming ASCII-to-floating-point (streamingatof)</h2>

<p><a href="https://github.com/jmtilli/streamingatof">streamingatof in Github</a></p>

<p>There are cases that the standard C library atof() function call do not
handle. For example, atof() is defined only for continuous '\0'-terminated
strings. Thus if you have a block of memory that is not guaranteed to be
'\0'-terminated, you need to allocate a second block of potentially unlimited
size to add the terminating '\0' character. Also, atof() requires all data to
be stored in continuous memory at once, so calling it incrementally for newly
arriving data blocks does not work. The only way to solve the incremental
parsing problem is to allocate a buffer that needs to grow to potentially
unbounded sizes to handle numbers such as 1e0, 10e-1, 100e-2, 1000e-3,
10000e-4, 100000e-5, ... which all represent the number 1 in a series of
representations that grow without bound. Streaming atof is designed to handle
all those use cases where standard atof() fails.</p>

<h2>caj: C API for JSON</h2>

<p><a href="https://github.com/jmtilli/caj">caj in Github</a></p>

<p>Usually JSON is parsed by a tree-based parser. If the data structures of the
parser are different from the ones used in the program, a conversion needs to
be performed to modify the parse tree to the desired format. CAJ is an
event-driven parser for C language that allows directly parsing to the desired
structures. CAJ also includes CAJUN, a tree-based variant; CAJ_out, a JSON
output library allowing outputting JSON from any function; and CAJUNfrag, a
parser combining the event-driven and tree-based approaches in a flexible
way.</p>

<h2>javajsonfrag</h2>

<p><a href="https://github.com/jmtilli/javajsonfrag">javajsonfrag in Github</a></p>

<p>Typically, JSON is parsed by a tree-based parser and almost never by an
event-based parser. Event-based parsers are fast and have a low memory
footprint, but a drawback is that it is cumbersome to write the required event
handlers. Tree-based parsers make the code easier to write, to understand and
to maintain but have a large memory footprint as a drawback. Usually, JSON is
not used for huge files such as database dumps that necessitate event-based
parsing, or so it would appear at a glance, because a tree-based parser cannot
hold the whole parse tree in memory at the same time, and event-based parsing
is not available in common libraries. JavaJSONFrag allows JSON to be parsed by
event-based approach from the top, but optionally allowing switching to a
tree-based approach for small structures. So for example a database dump
containing billion objects can be parsed in an event-based manner but each
object can be parsed into a tree. This allows using JSON for huge database
dumps, and JSON is a far better serialization format than XML.</p>

<h2>abce and Amyplan: a bytecode engine and a modifiable yacc-based language</h2>

<p><a href="https://github.com/Aalto5G/abce">abce in Github (Aalto5G)</a>, <a
href="https://github.com/jmtilli/abce">author's fork of abce</a></p>

<p>A bytecode engine (abce) is a very simple bytecode engine with JSON data
model and garbage collection, intended for strongly typed dynamic languages.
The opcode format is stable and the argument order of opcodes is natural,
meaning compiler can directly emit operations without reordering. A modifiable
yacc-based programming language (Amyplan) is the programming language for
writing abce programs.</p>

<h2>stirmake: scalable true implementation of recursive make</h2>

<p><a href="https://github.com/Aalto5G/stirmake">stirmake in Github
(Aalto5G)</a>, <a href="https://github.com/jmtilli/stirmake">author's fork of
stirmake</a></p>

<p>Stirmake is scalable true implementation of recursive make. It is intended
for easily creating whole-project build systems consisting of numerous modules.
Numerous deficiencies in standard make have been solved while staying true to
the idea of traditional make. For understanding why stirmake is necessary, read
<a href="http://aegis.sourceforge.net/auug97.pdf">"Recursive Make Considered
Harmful"</a> and try to follow its instructions. If you are interested in
stirmake, you probably want to read its <a href="https://jmtilli.github.io/stirmakeguide/">user's guide</a>.</p>

<h2>jmalloc: variable sized high performance memory allocator</h2>

<p><a href="https://github.com/Aalto5G/jmalloc">jmalloc in Github
(Aalto5G)</a>, <a href="https://github.com/jmtilli/jmalloc">author's fork of
stirmake</a></p>

<p>jmalloc is a variable-sized single-threaded memory allocator over 3 times
faster than standard Linux allocator. It is on a totally different location of
the high performance - low fragmentation scale, wasting memory but saving CPU
time. In contrast, other allocators waste CPU time but save memory.</p>

<h2>YaLe: Yet another Lexer eliminator, or Yacc+Lex combined</h2>

<p><a href="https://github.com/Aalto5G/yale">yale in Github (Aalto5G)</a>, <a
href="https://github.com/jmtilli/yale">author's fork of yale</a></p>

<p>YaLe is an event-driven incremental non-blocking network protocol parser
generator for a state machine architecture. YaLe implements a finitely
backtracking parser state dependent DFA based lexer for maximal munch
tokenizing with a priority system. Parsing is conditionalized
callback-attributed LL(1). The callback system is particularly sophisticated.
YaLe parses HTTP at over 3 Gbps, whereas its main competitor, BinPAC, parses
HTTP at 0.55 Gbps. YaLe can be used for both text and binary protocols.</p>

<h2>cghcpcli: carrier grade HTTP proxy client</h2>

<p><a href="https://github.com/Aalto5G/cghcpcli">cghcpcli in Github
(Aalto5G)</a>, <a href="https://github.com/jmtilli/cghcpcli">author's fork of
cghcpcli</a></p>

<p>Carrier grade HTTP CONNECT proxy client offers a client-side mechanism for
NAT traversal using a HTTP CONNECT proxy in the NAT middlebox.</p>

<h2>ldpairwall: L Data Plane Airwall</h2>

<p><a href="https://github.com/Aalto5G/ldpairwall">ldpairwall in Github
(Aalto5G)</a>, <a href="https://github.com/jmtilli/ldpairwall">author's fork of
ldpairall</a></p>

<p>The L Data Plane Airwall offers improved NAT traversal with no security
policy. It is a prototype of an application layer NAT technology.</p>

<h2>nmsynproxy: Netmap SYN proxy</h2>

<p><a href="https://github.com/Aalto5G/nmsynproxy">nmsynproxy in Github
(Aalto5G)</a>, <a href="https://github.com/jmtilli/nmsynproxy">author's fork of
nmsynproxy</a></p>

<p>The netmap SYN proxy offers state of the art TCP SYN proxy for protecting
against TCP SYN flood attacks at line rate. The TCP SYN cookie mechanism it
uses is particularly modern and well thought of. The feature set exceeds that
of the Linux SYN proxy iptables module. It is implemented entirely in user
space unlike the iptables module.</p>

<h2>PPTK: packet processing toolkit</h2>

<p><a href="https://github.com/Aalto5G/pptk">pptk in Github (Aalto5G)</a>, <a
href="https://github.com/jmtilli/pptk">author's fork of pptk</a></p>

<p>The packet processing toolkit contains several useful utilities for user
space packet processing on Linux machines. It also includes L Data Plane, a
data plane wrapper similar to OpenDataPlane but with higher netmap
performance.</p>

<h2>javaxmlfrag</h2>

<p><a href="https://github.com/jmtilli/javaxmlfrag">javaxmlfrag in
Github</a>, <a href="https://jmtilli.github.io/javaxmlfragjavadoc">javaxmlfrag documentation</a></p>

<p>Typically, XML is either parsed by a tree-based parser or by an event-based
parser. Event-based parsers are fast and have a low memory footprint, but a
drawback is that it is cumbersome to write the required event handlers.
Tree-based parsers make the code easier to write, to understand and to maintain
but have a large memory footprint as a drawback. Often, XML is used for huge
files such as database dumps that necessitate event-based parsing, or so it
would appear at a glance, because a tree-based parser cannot hold the whole
parse tree in memory at the same time. JavaXMLFrag allows XML to be parsed by
event-based approach from the top, but allowing switching to a tree-based
approach for small structures. So for example a database dump containing
billion objects can be parsed in an event-based manner but each object can be
parsed into a tree.</p>

<h2>javafastcomplex</h2>

<p><a href="https://github.com/jmtilli/javafastcomplex">javafastcomplex in Github</a>, <a href="https://jmtilli.github.io/javafastcomplexjavadoc">javafastcomplex documentation</a></p>

<p>Javafastcomplex implements two complex number classes, Complex for immutable
complex numbers and ComplexBuffer for mutable complex numbers. Both immutable
and mutable complex numbers share the same common ComplexNumber interface. This
is unlike other available complex number classes that typically only offer an
immutable complex number class. Using the mutable complex number class reduces
object creation and garbage collection overhead which allows trivially to
improve the performance of Java code that does complex number calculations.</p>

<h2>Micronova XRD</h2>

<p><a href="https://github.com/jmtilli/micronovaxrd">micronovaxrd in
Github</a></p>

<p>Micronova XRD is a fast and convenient user interface for fitting X-ray
diffraction curves of multilayers to data measured from heteroepitaxial
structures. It originally was only a front-end for Matlab / GNU Octave
differential evolution code written by Juha-Matti Tilli for measurements from
Philips / PANalytical equipment, but current version is pure Java, uses
optionally covariance enhanced multithreaded differential evolution for
fitting, and supports quite many data formats.</p>

<h2>Micronova XRR</h2>

<p><a href="https://github.com/jmtilli/micronovaxrr">micronovaxrr in
Github</a></p>

<p>Micronova XRR is a fast and convenient user interface for fitting X-ray
reflectivity curves of multilayers to measured data. It originally was only a
front-end for Matlab / GNU Octave genetic algorithm code written by Jouni
Tiilikainen for measurements from Philips / PANalytical equipment, but current
version is pure Java, uses optionally covariance enhanced multithreaded
differential evolution for fitting, and supports quite many data formats.</p>

<h2>XRDLab</h2>

<p><a href="https://github.com/jmtilli/xrdlab">xrdlab in Github</a></p>

<p>XRDLab is a set of functions for simulating X-ray diffraction curves of heteroepitaxial layers, and for fitting XRD curves to measured data. The functions have been developed and tested with GNU Octave. There is a possibility they might work with Matlab too, but that has not been tested.</p>

<p>Overall, for new users (and for developers who don't have a problem with Java), it is recommended to use Micronova XRD instead at <a href="https://github.com/jmtilli/micronovaxrd">https://github.com/jmtilli/micronovaxrd</a>.</p>

<h2>XRRLab</h2>

<p><a href="https://github.com/jmtilli/xrrlab">xrrlab in Github</a></p>

<p>XRRLab is a set of functions for simulating X-ray reflectivity curves of multilayers with Parratt's formalism, and for fitting XRR curves to measured data. The functions have been developed and tested with GNU Octave. There is a possibility they might work with Matlab too, but that has not been tested.</p>

<p>This project would not have been made without the help of Jouni Tiilikainen. However, the current code has been fully written by Juha-Matti Tilli and no code written by Jouni Tiilikainen remains.</p>

<p>Overall, for new users (and for developers who don't have a problem with Java), it is recommended to use Micronova XRR instead at <a href="https://github.com/jmtilli/micronovaxrr">https://github.com/jmtilli/micronovaxrr</a>.</p>

<h1>Juha-Matti Tilli at other sites</h1>

<ul>
	<li><a href="https://orcid.org/0000-0001-6033-4377">Juha-Matti Tilli's ORCID page</a></li>
	<li><a href="https://fi.linkedin.com/in/juha-matti-tilli">Juha-Matti Tilli's LinkedIn profile</a></li>
	<li><a href="https://github.com/jmtilli">Juha-Matti Tilli's Github profile</a></li>
</ul>

</body></html>
